#include <conio.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>
#include "Snake.h"
int main() {
    // MAP字符数组用于存储整个游戏界面的显示内容，其大小根据游戏区域相关维度计算得出
    char MAP[S * 2 + W + 3], *c = MAP;

    // m数组用于标记游戏区域中各个位置的状态，例如是否可通行、是否有物体等
    int m[S + 1];
    // q数组作为一个类似队列的数据结构，推测用于存储蛇身位置等相关信息（从索引l到r）
    int q[S];
    // l作为队列q的头索引，初始化为0
    int l = 0;
    // r作为队列q的尾索引，初始化为4
    int r = 4;
    // d表示移动方向，初始化为1，不同的值对应不同方向（如 -1、W、-W等，结合后续逻辑）
    int d = 1;
    // p用于记录当前游戏主角（比如蛇头）的位置索引
    int p;
    // a用于记录目标物体（比如食物）的位置索引
    int a;
    // i作为临时循环变量，用于多个循环中计数等操作
    int i;

    // 初始化队列q中的部分元素值为S，具体含义需结合完整游戏逻辑确定，可能是一种初始状态设定
    for (i = l; i <= r; ++i)
        q[i] = S;

    // 初始化游戏区域状态数组m以及构建游戏界面显示内容到MAP数组中
    for (i = 0; i < S; c += 2, ++i % W || (*c++ = '\n')) {
        // 根据游戏区域的行列位置判断每个位置的状态，这里通过条件判断排除了某些行列（边界或特定行列情况）
        // 如果满足条件则标记为可通行等情况（对应m[i]赋值为相应逻辑值）
        m[i] =!(i / W % (H - 1) && i % W % (W - 1));
        // 根据m[i]的值来确定在MAP数组对应位置填充的字符，若m[i]为真，填充'['和']'，可能表示墙体等；
        // 若为假，填充两个空格，表示空白可通行区域
        m[i]? (*c = '[', c[1] = ']') : (*c = c[1] = ' ');
    }

    // 初始化游戏主角（如蛇头）的初始位置，这里根据游戏区域宽度W、高度H以及方向相关的偏移量来计算
    p = W / 2 * (H + 1) - 1;
    // 初始化目标物体（如食物）的初始位置，相对于主角位置有一定偏移
    a = p + 1;
    // 给MAP数组添加字符串结束符，以便后续可以作为字符串进行输出显示
    c[-1] = '\0';

    // 初始化随机数生成器，以保证后续生成食物位置等操作能有较好的随机性（不过更合理的是在程序开始处初始化一次）
    srand((unsigned)time(0));

    // 游戏主循环，只要条件为真就一直循环执行游戏逻辑，直到满足退出条件跳出循环
    while (true) {
        // 检测是否有键盘按键按下，如果有则获取按键值并进行相应处理
        if (_kbhit() && (i = _getch() & 95)) {
            // 如果按下的是'A'键（代表向左方向，且当前移动方向不是向右，防止直接掉头等不符合逻辑的移动），则更新移动方向为向左（d = -1）
            if (i == 'A' && d!= 1)
                d = -1;
            // 如果按下的是'D'键（代表向右方向，且当前移动方向不是向左），则更新移动方向为向右（d = 1）
            else if (i == 'D' && d!= -1)
                d = 1;
            // 如果按下的是'W'键（代表向上方向，且当前移动方向不是向下），则更新移动方向为向上（d = -W）
            else if (i == 'W' && d!= W)
                d = -W;
            // 如果按下的是'S'键（代表向下方向，且当前移动方向不是向上），则更新移动方向为向下（d = W）
            else if (i == 'S' && d!= -W)
                d = W;
        }

        // 判断游戏是否结束，条件为：如果按照当前移动方向移动后（更新p的值，p += d），新位置在游戏区域状态数组m中表示不可行（m[p]为假）
        // 或者新位置和队列q中某个特定位置（q[l + 1]，可能与蛇身位置冲突有关）相等，又或者按下了Esc键（i == 27），则跳出游戏循环，游戏结束
        if (m[p += d] && p!= q[l + 1] || i == 27)
            break;

        // 如果蛇头位置p和目标物体（食物）位置a相等，说明吃到了食物，需要重新生成食物
        if (p == a) {
            // 通过循环不断寻找一个新的随机位置，该位置在游戏区域内（a = rand() % S）且满足是空闲可放置食物的位置（m[a]为真）
            for (a = rand() % S; m[a]; a = (a + 1) % S) {
            }
            // 在找到的新位置上，将MAP数组对应位置填充表示食物的字符'0'（两个连续的'0'，可能是显示格式需要）
            *(c = MAP + a * 2 + a / W) = '0', c[1] = '0';
        }
        // 如果没有吃到食物，执行以下逻辑，处理蛇身移动相关的操作
        else {
            // 将队列q头部（l指向的位置）对应的游戏区域位置（索引为i = q[l]）在m数组中标记为可通行（设置为0），表示蛇尾离开后的位置变为空闲
            m[i = q[l = (l + 1) % S]] = 0;
            // 同时将MAP数组中对应位置的字符更新为空格，实现界面上蛇尾消失的视觉效果
            *(c = MAP + i * 2 + i / W) = ' ', c[1] = ' ';
        }

        // 将当前蛇头位置p更新到队列q的尾部（r指向的位置），表示蛇身位置的更新
        m[q[r] = p] = 1;
        // 更新队列尾索引r，实现队列的循环更新，保持对蛇身位置的正确记录
        r = (r + 1) % S;

        // 在MAP数组中蛇头所在的新位置上，填充表示蛇头的字符'('和')'（可能是显示格式需要）
        *(c = MAP + p * 2 + p / W) = '(', c[1] = ')';

        // 清屏操作，用于更新游戏界面显示，不同操作系统下system("cls")行为略有不同，存在可移植性问题
        system("cls");
        // 输出MAP数组内容，也就是显示更新后的游戏界面
        puts(MAP);

        // 暂停200毫秒，控制游戏的帧率，使游戏画面更新有合适的频率，避免过快闪烁等情况
        Sleep(200);
    }

    // 游戏结束后，输出提示信息"Game over!"
    printf("\nGame over!\n");

    return 0;
}